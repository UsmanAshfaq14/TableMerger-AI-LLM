
import sys
sys.stdout.reconfigure(encoding='utf-8')
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()e', 'position'}
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()nt', 'location'}
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()Union[str, None]:
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()columns)}. Please provide complete data."
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator() -> Union[str, None]:
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()']):
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()d. Expected integer."
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()cted string."
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()ted integer."
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator())
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()id_ages}. Employees must be at least 18 years old."
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()Expected string."
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()']):
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()d. Expected integer."
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()):
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator(). Expected string."
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()Expected string."
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()ne]:
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()"
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()'].tolist()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()s}. Please provide unique primary keys."
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()t_df: pd.DataFrame) -> List[int]:
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()e table."""
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()_id'])]['employee_id'].tolist()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()me) -> Tuple[pd.DataFrame, Dict]:
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator() of unassigned departments."""
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()f, dept_df)
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator() in department assignments but not in employee records."
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()pt_ids)
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()ployee_id'])]
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()'left')
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()d'
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()rom department records. Assigned 'Unassigned'."
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()nt_data: Union[str, Dict], 
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()])
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()ee')
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()ult}
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()ployee')
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()ult}
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()ult}
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()tment')
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()ult}
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()epartment')
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()ult}
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()d: {str(e)}"}
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()input_format='csv')
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()
import pandas as pd
import json
from typing import Union, Dict, List, Tuple
from io import StringIO

class TableMergeValidator:
    def __init__(self):
        self.required_employee_columns = {'employee_id', 'name', 'age', 'position'}
        self.required_department_columns = {'employee_id', 'department', 'location'}
        
    def validate_schema(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate that all required columns are present."""
        if table_type == 'employee':
            required_columns = self.required_employee_columns
        else:
            required_columns = self.required_department_columns
            
        missing_columns = required_columns - set(df.columns)
        if missing_columns:
            return f"ERROR: Missing required columns: {list(missing_columns)}. Please provide complete data."
        return None

    def validate_data_types(self, df: pd.DataFrame, table_type: str) -> Union[str, None]:
        """Validate data types for each column in the dataframe."""
        try:
            if table_type == 'employee':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check name is string
                if not pd.api.types.is_string_dtype(df['name']):
                    return f"ERROR: Invalid data type for name. Expected string."
                
                # Check age is integer and >= 18
                if not pd.api.types.is_integer_dtype(df['age']):
                    return f"ERROR: Invalid data type for age. Expected integer."
                if (df['age'] < 18).any():
                    invalid_ages = df[df['age'] < 18]['age'].tolist()
                    return f"ERROR: Invalid age values found: {invalid_ages}. Employees must be at least 18 years old."
                
                # Check position is string
                if not pd.api.types.is_string_dtype(df['position']):
                    return f"ERROR: Invalid data type for position. Expected string."
                
            elif table_type == 'department':
                # Check employee_id is integer
                if not pd.api.types.is_integer_dtype(df['employee_id']):
                    return f"ERROR: Invalid data type for employee_id. Expected integer."
                
                # Check department and location are strings
                if not pd.api.types.is_string_dtype(df['department']):
                    return f"ERROR: Invalid data type for department. Expected string."
                if not pd.api.types.is_string_dtype(df['location']):
                    return f"ERROR: Invalid data type for location. Expected string."
                
            return None
        except Exception as e:
            return f"ERROR: Data type validation failed - {str(e)}"

    def check_duplicate_ids(self, df: pd.DataFrame) -> Union[str, None]:
        """Check for duplicate employee IDs in the employee table."""
        duplicates = df[df.duplicated(['employee_id'])]['employee_id'].tolist()
        if duplicates:
            return f"ERROR: Duplicate employee IDs found: {duplicates}. Please provide unique primary keys."
        return None

    def check_foreign_key_constraint(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> List[int]:
        """Check if all department employee IDs exist in the employee table."""
        return dept_df[~dept_df['employee_id'].isin(emp_df['employee_id'])]['employee_id'].tolist()

    def merge_tables(self, emp_df: pd.DataFrame, dept_df: pd.DataFrame) -> Tuple[pd.DataFrame, Dict]:
        """Merge employee and department tables with proper handling of unassigned departments."""
        summary = {
            'total_employees': len(emp_df),
            'successfully_merged': 0,
            'unassigned_records': 0,
            'invalid_department_records': 0,
            'warnings': []
        }

        # Remove department records with invalid employee IDs
        unmatched_dept_ids = self.check_foreign_key_constraint(emp_df, dept_df)
        if unmatched_dept_ids:
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unmatched_dept_ids} found in department assignments but not in employee records."
            )
            summary['invalid_department_records'] = len(unmatched_dept_ids)
            dept_df = dept_df[dept_df['employee_id'].isin(emp_df['employee_id'])]

        # Perform left merge to keep all employees
        merged_df = pd.merge(emp_df, dept_df, on='employee_id', how='left')
        
        # Handle missing department assignments
        mask = merged_df['department'].isna()
        merged_df.loc[mask, ['department', 'location']] = 'Unassigned'
        
        # Update summary
        summary['successfully_merged'] = len(merged_df[~mask])
        summary['unassigned_records'] = len(merged_df[mask])
        
        if summary['unassigned_records'] > 0:
            unassigned_ids = merged_df[mask]['employee_id'].tolist()
            summary['warnings'].append(
                f"WARNING: Employee ID(s) {unassigned_ids} missing from department records. Assigned 'Unassigned'."
            )

        return merged_df, summary

    def process_data(self, employee_data: Union[str, Dict], department_data: Union[str, Dict], 
                    input_format: str = 'json') -> Dict:
        """Main function to process and merge the tables."""
        try:
            # Convert input data to DataFrames based on format
            if input_format.lower() == 'csv':
                if isinstance(employee_data, str):
                    emp_df = pd.read_csv(StringIO(employee_data))
                    dept_df = pd.read_csv(StringIO(department_data))
                else:
                    emp_df = pd.read_csv(employee_data)
                    dept_df = pd.read_csv(department_data)
            else:  # JSON format
                if isinstance(employee_data, str):
                    employee_data = json.loads(employee_data)
                    department_data = json.loads(department_data)
                emp_df = pd.DataFrame(employee_data['employees'])
                dept_df = pd.DataFrame(department_data['departments'])

            # Validate employee table
            validation_result = self.validate_schema(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(emp_df, 'employee')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.check_duplicate_ids(emp_df)
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Validate department table
            validation_result = self.validate_schema(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}
            
            validation_result = self.validate_data_types(dept_df, 'department')
            if validation_result:
                return {'status': 'error', 'message': validation_result}

            # Merge tables and get summary
            merged_df, summary = self.merge_tables(emp_df, dept_df)

            # Prepare output based on input format
            if input_format.lower() == 'csv':
                output_data = merged_df.to_csv(index=False)
            else:
                output_data = merged_df.to_dict(orient='records')

            return {
                'status': 'success',
                'data': output_data,
                'summary': summary
            }

        except Exception as e:
            return {'status': 'error', 'message': f"Processing failed: {str(e)}"}

def test_validator():
    """Function to test the TableMergeValidator with sample data"""
    print("🔄 Starting Table Merge Validation Test\n")
    
    # Initialize validator
    validator = TableMergeValidator()
    
    # Updated test data
    employee_data = """employee_id, name, age, position  
1, Henry Page, 30, Software Engineer  
2, Kasimir Hess, 25, Data Analyst  
3, Abigail Ryan, 28, Project Manager  
4, Rosalyn Michael, 32, UX Designer  
5, Jonah Ashley, 27, DevOps Engineer"""

    department_data = """employee_id, department, location  
1, Engineering, New York  
2, Data Science, San Francisco  
3, Product Management, Chicago  
4, Design, Austin  
5, DevOps, Austin"""

    print("📊 Input Data:")
    print("\nEmployee Records:")
    print(employee_data)
    print("\nDepartment Assignments:")
    print(department_data)
    print("\n" + "="*50 + "\n")

    # Process the data
    result = validator.process_data(employee_data, department_data, input_format='csv')
    
    print("🔍 Validation and Merge Results:\n")
    if result['status'] == 'success':
        print("✅ Process completed with warnings\n")
        
        print("📈 Summary:")
        for key, value in result['summary'].items():
            if key != 'warnings':
                print(f"- {key.replace('_', ' ').title()}: {value}")
        
        if result['summary']['warnings']:
            print("\n⚠️ Warnings:")
            for warning in result['summary']['warnings']:
                print(f"- {warning}")
        
        print("\n📋 Merged Data:")
        if isinstance(result['data'], str):
            merged_df = pd.read_csv(StringIO(result['data']))
        else:
            merged_df = pd.DataFrame(result['data'])
            
        # Format the output table
        print("\n" + "="*80)
        print(merged_df.to_string(index=False))
        print("="*80)
        
    else:
        print("❌ Error occurred:")
        print(result['message'])
    
    print("\n" + "="*50)

# Run the test
if __name__ == "__main__":
    test_validator()